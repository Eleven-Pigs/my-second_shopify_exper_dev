# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

module RestClient
  def self.add_before_execution_proc(&proc); end
  def self.before_execution_procs; end
  def self.create_log(param); end
  def self.delete(url, headers = _, &block); end
  def self.get(url, headers = _, &block); end
  def self.head(url, headers = _, &block); end
  def self.log; end
  def self.log=(log); end
  def self.options(url, headers = _, &block); end
  def self.patch(url, payload, headers = _, &block); end
  def self.post(url, payload, headers = _, &block); end
  def self.proxy; end
  def self.proxy=(_); end
  def self.put(url, payload, headers = _, &block); end
  def self.reset_before_execution_procs; end
  def self.version; end
end

module RestClient::AbstractResponse
  def args; end
  def code; end
  def cookies; end
  def description; end
  def follow_redirection(request = _, result = _, &block); end
  def headers; end
  def net_http_res; end
  def raw_headers; end
  def return!(request = _, result = _, &block); end
  def to_i; end

  private

  def parse_cookie(cookie_content); end

  def self.beautify_headers(headers); end
end

class RestClient::Accepted < ::RestClient::RequestFailed
  def message; end
end

class RestClient::BadGateway < ::RestClient::RequestFailed
  def message; end
end

class RestClient::BadRequest < ::RestClient::RequestFailed
  def message; end
end

class RestClient::BandwidthLimitExceeded < ::RestClient::RequestFailed
  def message; end
end

class RestClient::BlockedByWindowsParentalControls < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Conflict < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Continue < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Created < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Exception < ::RuntimeError
  def initialize(response = _, initial_response_code = _); end

  def http_body; end
  def http_code; end
  def inspect; end
  def message; end
  def message=(_); end
  def response; end
  def response=(_); end
  def to_s; end
end

class RestClient::ExceptionWithResponse < ::RestClient::Exception
end

module RestClient::Exceptions
end

RestClient::Exceptions::EXCEPTIONS_MAP = T.let(T.unsafe(nil), Hash)

class RestClient::ExpectationFailed < ::RestClient::RequestFailed
  def message; end
end

class RestClient::FailedDependency < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Forbidden < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Found < ::RestClient::RequestFailed
  def message; end
end

class RestClient::GatewayTimeout < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Gone < ::RestClient::RequestFailed
  def message; end
end

class RestClient::HTTPVersionNotSupported < ::RestClient::RequestFailed
  def message; end
end

class RestClient::ImATeapot < ::RestClient::RequestFailed
  def message; end
end

class RestClient::InsufficientStorage < ::RestClient::RequestFailed
  def message; end
end

class RestClient::InternalServerError < ::RestClient::RequestFailed
  def message; end
end

class RestClient::LengthRequired < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Locked < ::RestClient::RequestFailed
  def message; end
end

class RestClient::MaxRedirectsReached < ::RestClient::Exception
  def message; end
end

class RestClient::MethodNotAllowed < ::RestClient::RequestFailed
  def message; end
end

class RestClient::MovedPermanently < ::RestClient::RequestFailed
  def message; end
end

class RestClient::MultiStatus < ::RestClient::RequestFailed
  def message; end
end

class RestClient::MultipleChoices < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NetworkAuthenticationRequired < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NoContent < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NonAuthoritativeInformation < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NotAcceptable < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NotExtended < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NotImplemented < ::RestClient::RequestFailed
  def message; end
end

class RestClient::NotModified < ::RestClient::ExceptionWithResponse
  def message; end
end

class RestClient::OK < ::RestClient::RequestFailed
  def message; end
end

class RestClient::PartialContent < ::RestClient::RequestFailed
  def message; end
end

module RestClient::Payload
  extend(::RestClient::Payload)

  def generate(params); end
  def has_file?(params); end
  def has_file_array?(params); end
end

class RestClient::Payload::Base
  def initialize(params); end

  def build_stream(params); end
  def close; end
  def flatten_params(params, parent_key = _); end
  def flatten_params_array(value, calculated_key); end
  def headers; end
  def inspect; end
  def length; end
  def read(bytes = _); end
  def short_inspect; end
  def size; end
  def to_s(bytes = _); end
end

class RestClient::Payload::Multipart < ::RestClient::Payload::Base
  def boundary; end
  def build_stream(params); end
  def close; end
  def create_file_field(s, k, v); end
  def create_regular_field(s, k, v); end
  def handle_key(key); end
  def headers; end
  def mime_for(path); end
end

RestClient::Payload::Multipart::EOL = T.let(T.unsafe(nil), String)

class RestClient::Payload::Streamed < ::RestClient::Payload::Base
  def build_stream(params = _); end
  def length; end
  def size; end
end

class RestClient::Payload::UrlEncoded < ::RestClient::Payload::Base
  def build_stream(params = _); end
  def handle_key(key); end
  def headers; end
end

RestClient::Payload::UrlEncoded::Escape = T.let(T.unsafe(nil), Regexp)

RestClient::Payload::UrlEncoded::Parser = T.let(T.unsafe(nil), URI::RFC2396_Parser)

class RestClient::PaymentRequired < ::RestClient::RequestFailed
  def message; end
end

module RestClient::Platform
  def self.jruby?; end
  def self.mac_mri?; end
  def self.windows?; end
end

class RestClient::PreconditionFailed < ::RestClient::RequestFailed
  def message; end
end

class RestClient::PreconditionRequired < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Processing < ::RestClient::RequestFailed
  def message; end
end

class RestClient::ProxyAuthenticationRequired < ::RestClient::RequestFailed
  def message; end
end

class RestClient::RawResponse
  include(::RestClient::AbstractResponse)

  def initialize(tempfile, net_http_res, args); end

  def file; end
  def size; end
  def to_s; end
end

class RestClient::Redirect < ::RestClient::Exception
  def initialize(url); end

  def message; end
  def url; end
  def url=(_); end
end

class RestClient::Request
  def initialize(args); end

  def args; end
  def cookies; end
  def default_headers; end
  def execute(&block); end
  def fetch_body(http_response); end
  def headers; end
  def log_request; end
  def log_response(res); end
  def make_headers(user_headers); end
  def max_redirects; end
  def method; end
  def net_http_class; end
  def net_http_do_request(http, req, body = _, &block); end
  def net_http_request_class(method); end
  def open_timeout; end
  def parse_url(url); end
  def parse_url_with_auth(url); end
  def password; end
  def payload; end
  def print_verify_callback_warnings; end
  def process_payload(p = _, parent_key = _); end
  def process_result(res, &block); end
  def process_url_params(url, headers); end
  def processed_headers; end
  def raw_response; end
  def setup_credentials(req); end
  def ssl_ca_file; end
  def ssl_ca_path; end
  def ssl_cert_store; end
  def ssl_ciphers; end
  def ssl_client_cert; end
  def ssl_client_key; end
  def ssl_opts; end
  def ssl_verify_callback; end
  def ssl_verify_callback_warnings; end
  def ssl_version; end
  def stringify_headers(headers); end
  def timeout; end
  def transmit(uri, req, payload, &block); end
  def url; end
  def user; end
  def valid_cookie_key?(string); end
  def valid_cookie_value?(value); end
  def verify_ssl; end

  private

  def maybe_convert_extension(ext); end
  def parser; end

  def self.decode(content_encoding, body); end
  def self.default_ssl_cert_store; end
  def self.execute(args, &block); end
end

RestClient::Request::DefaultCiphers = T.let(T.unsafe(nil), String)

RestClient::Request::Redirect = RestClient::Redirect

RestClient::Request::RequestFailed = RestClient::RequestFailed

RestClient::Request::SSLOptionList = T.let(T.unsafe(nil), Array)

RestClient::Request::Unauthorized = RestClient::Unauthorized

RestClient::Request::WeakDefaultCiphers = T.let(T.unsafe(nil), Set)

class RestClient::RequestEntityTooLarge < ::RestClient::RequestFailed
  def message; end
end

class RestClient::RequestFailed < ::RestClient::ExceptionWithResponse
  def message; end
  def to_s; end
end

class RestClient::RequestHeaderFieldsTooLarge < ::RestClient::RequestFailed
  def message; end
end

class RestClient::RequestTimeout < ::RestClient::RequestFailed
  def message; end
end

class RestClient::RequestURITooLong < ::RestClient::RequestFailed
  def message; end
end

class RestClient::RequestedRangeNotSatisfiable < ::RestClient::RequestFailed
  def message; end
end

class RestClient::ResetContent < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Resource
  def initialize(url, options = _, backwards_compatibility = _, &block); end

  def [](suburl, &new_block); end
  def block; end
  def concat_urls(url, suburl); end
  def delete(additional_headers = _, &block); end
  def get(additional_headers = _, &block); end
  def head(additional_headers = _, &block); end
  def headers; end
  def open_timeout; end
  def options; end
  def password; end
  def patch(payload, additional_headers = _, &block); end
  def post(payload, additional_headers = _, &block); end
  def put(payload, additional_headers = _, &block); end
  def timeout; end
  def to_s; end
  def url; end
  def user; end
end

class RestClient::ResourceNotFound < ::RestClient::ExceptionWithResponse
  def message; end
end

module RestClient::Response
  include(::RestClient::AbstractResponse)

  def args; end
  def args=(_); end
  def body; end
  def net_http_res; end
  def net_http_res=(_); end

  def self.create(body, net_http_res, args); end
end

module RestClient::ResponseForException
  def method_missing(symbol, *args); end
end

class RestClient::RetryWith < ::RestClient::RequestFailed
  def message; end
end

class RestClient::SSLCertificateNotVerified < ::RestClient::Exception
  def initialize(message); end
end

RestClient::STATUSES = T.let(T.unsafe(nil), Hash)

class RestClient::SeeOther < ::RestClient::RequestFailed
  def message; end
end

class RestClient::ServerBrokeConnection < ::RestClient::Exception
  def initialize(message = _); end
end

class RestClient::ServiceUnavailable < ::RestClient::RequestFailed
  def message; end
end

class RestClient::SwitchProxy < ::RestClient::RequestFailed
  def message; end
end

class RestClient::SwitchingProtocols < ::RestClient::RequestFailed
  def message; end
end

class RestClient::TemporaryRedirect < ::RestClient::RequestFailed
  def message; end
end

class RestClient::TooManyConnectionsFromThisIP < ::RestClient::RequestFailed
  def message; end
end

class RestClient::TooManyRequests < ::RestClient::RequestFailed
  def message; end
end

class RestClient::Unauthorized < ::RestClient::ExceptionWithResponse
  def message; end
end

class RestClient::UnorderedCollection < ::RestClient::RequestFailed
  def message; end
end

class RestClient::UnprocessableEntity < ::RestClient::RequestFailed
  def message; end
end

class RestClient::UnsupportedMediaType < ::RestClient::RequestFailed
  def message; end
end

class RestClient::UpgradeRequired < ::RestClient::RequestFailed
  def message; end
end

class RestClient::UseProxy < ::RestClient::RequestFailed
  def message; end
end

RestClient::VERSION = T.let(T.unsafe(nil), String)

class RestClient::VariantAlsoNegotiates < ::RestClient::RequestFailed
  def message; end
end

module RestClient::Windows
end
