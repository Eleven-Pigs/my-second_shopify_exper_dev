# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

module T
  def self.all(type_a, type_b, *types); end
  def self.any(type_a, type_b, *types); end
  def self.assert_type!(value, type, checked: _); end
  def self.cast(value, type, checked: _); end
  def self.class_of(klass); end
  def self.enum(values); end
  def self.let(value, type, checked: _); end
  def self.must(arg); end
  def self.nilable(type); end
  def self.noreturn; end
  def self.proc; end
  def self.reveal_type(value); end
  def self.self_type; end
  def self.type_alias(type); end
  def self.type_parameter(name); end
  def self.unsafe(value); end
  def self.untyped; end
end

module T::AbstractUtils
  def self.abstract_method?(method); end
  def self.abstract_methods_for(mod); end
  def self.abstract_module?(mod); end
  def self.declared_abstract_methods_for(mod); end
end

T::AbstractUtils::Methods = T::Private::Methods

module T::Array
  def self.[](type); end
end

T::Boolean = T.let(T.unsafe(nil), T::Types::Union)

module T::Configuration
  def self.call_validation_error_handler(signature, opts); end
  def self.call_validation_error_handler=(value); end
  def self.default_checked_level=(default_checked_level); end
  def self.enable_checking_for_sigs_marked_checked_tests; end
  def self.hard_assert_handler(str, extra); end
  def self.hard_assert_handler=(value); end
  def self.inline_type_error_handler(error); end
  def self.inline_type_error_handler=(value); end
  def self.log_info_handler(str, extra); end
  def self.log_info_handler=(value); end
  def self.scalar_types; end
  def self.scalar_types=(values); end
  def self.sig_builder_error_handler(error, location); end
  def self.sig_builder_error_handler=(value); end
  def self.sig_validation_error_handler(error, opts); end
  def self.sig_validation_error_handler=(value); end
  def self.soft_assert_handler(str, extra); end
  def self.soft_assert_handler=(value); end
end

module T::Enumerable
  def self.[](type); end
end

module T::Enumerator
  def self.[](type); end
end

module T::Generic
  include(::T::Helpers)

  def [](*types); end
  def type_member(variance = _, fixed: _); end
  def type_template(variance = _, fixed: _); end
end

module T::Hash
  def self.[](keys, values); end
end

module T::Helpers
  def abstract!; end
  def interface!; end
  def mixes_in_class_methods(mod); end
end

T::Helpers::Private = T::Private

class T::InterfaceWrapper
  extend(::T::Sig)

  def initialize(target_obj, interface_mod); end

  def __interface_mod_DO_NOT_USE; end
  def __target_obj_DO_NOT_USE; end
  def is_a?(other); end
  def kind_of?(other); end

  def self.dynamic_cast(obj, mod); end
  def self.self_methods; end
  def self.wrap_instance(obj, interface_mod); end
  def self.wrap_instances(*args, &blk); end
  def self.wrapped_dynamic_cast(obj, mod); end
end

module T::InterfaceWrapper::Helpers
  def wrap_instance(obj); end
  def wrap_instances(arr); end
end

module T::Profile
  def self.reset; end
  def self.typecheck_count_estimate; end
  def self.typecheck_duration; end
  def self.typecheck_duration=(_); end
  def self.typecheck_duration_estimate; end
  def self.typecheck_sample_attempts; end
  def self.typecheck_sample_attempts=(_); end
  def self.typecheck_samples; end
  def self.typecheck_samples=(_); end
end

T::Profile::SAMPLE_RATE = T.let(T.unsafe(nil), Integer)

module T::Props
  extend(::T::Private::MixesInClassMethods)
  extend(::T::Helpers)
end

module T::Props::ClassMethods
  extend(::T::Helpers)
  extend(::T::Sig)

  def const(*args, &blk); end
  def decorator; end
  def decorator_class; end
  def extended(child); end
  def included(child); end
  def inherited(child); end
  def plugin(mod); end
  def plugins; end
  def prepended(child); end
  def prop(name, cls, rules = _); end
  def props; end
  def reload_decorator!; end
  def validate_prop_value(prop, val); end
end

module T::Props::Constructor
  include(::T::Props::WeakConstructor)
  include(::T::Props::Optional)
  include(::T::Props::Plugin)
  include(::T::Props)
  extend(::T::Props::Plugin::ClassMethods)
  extend(::T::Props::ClassMethods)

  def initialize(hash = _); end
end

module T::Props::CustomType
  def deserialize(_mongo_scalar); end
  def instance?(_value); end
  def serialize(_instance); end
  def valid?(value); end

  def self.included(_base); end
  def self.scalar_type?(val); end
  def self.valid_serialization?(val, type = _); end
end

class T::Props::Decorator
  extend(::T::Sig)

  def initialize(klass); end

  def add_prop_definition(*args, &blk); end
  def all_props(*args, &blk); end
  def decorated_class; end
  def foreign_prop_get(*args, &blk); end
  def get(*args, &blk); end
  def model_inherited(child); end
  def mutate_prop_backdoor!(*args, &blk); end
  def plugin(mod); end
  def prop_defined(*args, &blk); end
  def prop_get(*args, &blk); end
  def prop_rules(*args, &blk); end
  def prop_set(*args, &blk); end
  def prop_validate_definition!(*args, &blk); end
  def props; end
  def set(*args, &blk); end
  def valid_props(*args, &blk); end
  def validate_prop_value(*args, &blk); end

  private

  def array_subdoc_type(*args, &blk); end
  def check_prop_type(*args, &blk); end
  def convert_type_to_class(*args, &blk); end
  def define_foreign_method(*args, &blk); end
  def define_getter_and_setter(*args, &blk); end
  def handle_foreign_hint_only_option(*args, &blk); end
  def handle_foreign_option(*args, &blk); end
  def handle_redaction_option(*args, &blk); end
  def hash_key_custom_type(*args, &blk); end
  def hash_value_subdoc_type(*args, &blk); end
  def is_nilable?(*args, &blk); end
  def shallow_clone_ok(*args, &blk); end
  def smart_coerce(*args, &blk); end
  def validate_foreign_option(*args, &blk); end
  def validate_not_missing_sensitivity(*args, &blk); end
  def validate_prop_name(name); end
end

T::Props::Decorator::DecoratedClass = T.let(T.unsafe(nil), T::Types::Untyped)

T::Props::Decorator::DecoratedInstance = T.let(T.unsafe(nil), T::Types::Untyped)

class T::Props::Decorator::NoRulesError < ::StandardError
end

module T::Props::Decorator::Private
  def self.apply_class_methods(plugin, target); end
  def self.apply_decorator_methods(plugin, target); end
end

T::Props::Decorator::PropType = T.let(T.unsafe(nil), T::Types::Union)

T::Props::Decorator::PropTypeOrClass = T.let(T.unsafe(nil), T::Types::Union)

T::Props::Decorator::Rules = T.let(T.unsafe(nil), T::Types::TypedHash)

T::Props::Decorator::TYPES_NOT_NEEDING_CLONE = T.let(T.unsafe(nil), Array)

class T::Props::Error < ::StandardError
end

class T::Props::ImmutableProp < ::T::Props::Error
end

class T::Props::InvalidValueError < ::T::Props::Error
end

module T::Props::Optional
  include(::T::Props::Plugin)
  include(::T::Props)
  extend(::T::Props::ClassMethods)
  extend(::T::Props::Plugin::ClassMethods)
end

module T::Props::Optional::DecoratorMethods
  def add_prop_definition(prop, rules); end
  def compute_derived_rules(rules); end
  def get_default(rules, instance_class); end
  def has_default?(rules); end
  def mutate_prop_backdoor!(prop, key, value); end
  def prop_optional?(prop); end
  def prop_validate_definition!(name, cls, rules, type); end
  def valid_props; end
end

T::Props::Optional::DecoratorMethods::VALID_OPTIONAL_RULES = T.let(T.unsafe(nil), Set)

module T::Props::Plugin
  include(::T::Props)
  extend(::T::Private::MixesInClassMethods)
  extend(::T::Helpers)
  extend(::T::Props::ClassMethods)
end

module T::Props::Plugin::ClassMethods
  def included(child); end
end

module T::Props::PrettyPrintable
  include(::T::Props::Plugin)
  include(::T::Props)
  extend(::T::Props::ClassMethods)
  extend(::T::Props::Plugin::ClassMethods)

  def inspect; end
  def pretty_inspect; end
end

module T::Props::PrettyPrintable::DecoratorMethods
  extend(::T::Sig)

  def inspect_instance(*args, &blk); end
  def valid_props(*args, &blk); end

  private

  def inspect_instance_components(*args, &blk); end
  def inspect_prop_value(*args, &blk); end
  def join_props_with_pretty_values(*args, &blk); end
end

module T::Props::Serializable
  include(::T::Props::PrettyPrintable)
  include(::T::Props::Optional)
  include(::T::Props::Plugin)
  include(::T::Props)
  extend(::T::Props::ClassMethods)
  extend(::T::Props::Plugin::ClassMethods)

  def deserialize(hash, strict = _); end
  def required_prop_missing_from_deserialize(prop); end
  def required_prop_missing_from_deserialize?(prop); end
  def serialize(strict = _); end
  def with(changed_props); end

  private

  def recursive_stringify_keys(obj); end
  def with_existing_hash(changed_props, existing_hash:); end
end

module T::Props::Serializable::ClassMethods
  def from_hash(hash, strict = _); end
  def from_hash!(hash); end
  def prop_by_serialized_forms; end
end

module T::Props::Serializable::DecoratorMethods
  def add_prop_definition(prop, rules); end
  def extra_props(instance); end
  def from_hash(hash, strict = _); end
  def get_id(instance); end
  def prop_by_serialized_forms; end
  def prop_dont_store?(prop); end
  def prop_serialized_form(prop); end
  def prop_validate_definition!(name, cls, rules, type); end
  def required_props; end
  def serialized_form_prop(serialized_form); end
  def valid_props; end

  private

  def inspect_instance_components(instance, multiline:, indent:); end
end

module T::Props::TypeValidation
  include(::T::Props::Plugin)
  include(::T::Props)
  extend(::T::Props::ClassMethods)
  extend(::T::Props::Plugin::ClassMethods)
end

T::Props::TypeValidation::BANNED_TYPES = T.let(T.unsafe(nil), Array)

module T::Props::TypeValidation::DecoratorMethods
  extend(::T::Sig)

  def prop_validate_definition!(*args, &blk); end
  def valid_props(*args, &blk); end

  private

  def find_invalid_subtype(*args, &blk); end
  def type_error_message(*args, &blk); end
  def validate_type(*args, &blk); end
end

class T::Props::TypeValidation::UnderspecifiedType < ::ArgumentError
end

module T::Props::Utils
  def self.deep_clone_object(what, freeze: _); end
  def self.merge_serialized_optional_rule(prop_rules); end
  def self.need_nil_read_check?(prop_rules); end
  def self.need_nil_write_check?(prop_rules); end
  def self.optional_prop?(prop_rules); end
  def self.required_prop?(prop_rules); end
end

module T::Props::WeakConstructor
  include(::T::Props::Optional)
  include(::T::Props::Plugin)
  include(::T::Props)
  extend(::T::Props::Plugin::ClassMethods)
  extend(::T::Props::ClassMethods)

  def initialize(hash = _); end
end

module T::Range
  def self.[](type); end
end

module T::Set
  def self.[](type); end
end

module T::Sig
  def sig(&blk); end
end

module T::Sig::WithoutRuntime
  def self.sig(&blk); end
end

class T::Struct < ::T::InexactStruct
  def self.inherited(subclass); end
end

module T::Types
end

class T::Types::Base
  def ==(other); end
  def describe_obj(obj); end
  def eql?(other); end
  def error_message_for_obj(obj); end
  def hash; end
  def name; end
  def subtype_of?(t2); end
  def to_s; end
  def valid?(obj); end
  def validate!(obj); end

  private

  def subtype_of_single?(type); end

  def self.method_added(method_name); end
end

class T::Types::ClassOf < ::T::Types::Base
  def initialize(type); end

  def describe_obj(obj); end
  def name; end
  def subtype_of_single?(other); end
  def type; end
  def valid?(obj); end
end

class T::Types::Enum < ::T::Types::Base
  extend(::T::Sig)

  def initialize(*args, &blk); end

  def describe_obj(obj); end
  def name; end
  def valid?(obj); end
  def values; end

  private

  def subtype_of_single?(other); end

  def self.method_added(name); end
end

class T::Types::FixedArray < ::T::Types::Base
  def initialize(types); end

  def describe_obj(obj); end
  def name; end
  def types; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::FixedHash < ::T::Types::Base
  def initialize(types); end

  def describe_obj(obj); end
  def name; end
  def types; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::Intersection < ::T::Types::Base
  def initialize(types); end

  def name; end
  def types; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::NoReturn < ::T::Types::Base
  def initialize; end

  def name; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::Proc < ::T::Types::Base
  def initialize(arg_types, returns); end

  def arg_types; end
  def name; end
  def returns; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::SelfType < ::T::Types::Base
  def initialize; end

  def name; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::Simple < ::T::Types::Base
  def initialize(raw_type); end

  def name; end
  def raw_type; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Types::TypeMember < ::T::Types::TypeVariable
end

class T::Types::TypeParameter < ::T::Types::Base
  def initialize(name); end

  def name; end
  def subtype_of_single?(type); end
  def valid?(obj); end
end

class T::Types::TypeTemplate < ::T::Types::TypeVariable
end

class T::Types::TypeVariable < ::T::Types::Base
  def initialize(variance); end

  def name; end
  def subtype_of_single?(type); end
  def valid?(obj); end
  def variance; end
end

T::Types::TypeVariable::VALID_VARIANCES = T.let(T.unsafe(nil), Array)

class T::Types::TypedArray < ::T::Types::TypedEnumerable
  def name; end
  def new(*args); end
  def valid?(obj); end
end

class T::Types::TypedEnumerable < ::T::Types::Base
  def initialize(type); end

  def describe_obj(obj); end
  def name; end
  def type; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
  def type_from_instance(obj); end
  def type_from_instances(objs); end
end

class T::Types::TypedEnumerator < ::T::Types::TypedEnumerable
  def name; end
  def new(*args, &blk); end
  def type; end
  def valid?(obj); end
end

class T::Types::TypedHash < ::T::Types::TypedEnumerable
  def initialize(keys:, values:); end

  def keys; end
  def name; end
  def new(*args, &blk); end
  def valid?(obj); end
  def values; end
end

class T::Types::TypedRange < ::T::Types::TypedEnumerable
  def name; end
  def new(*args); end
  def type; end
  def valid?(obj); end
end

class T::Types::TypedSet < ::T::Types::TypedEnumerable
  def name; end
  def new(*args); end
  def type; end
  def valid?(obj); end
end

class T::Types::Union < ::T::Types::Base
  def initialize(types); end

  def name; end
  def types; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
  def type_shortcuts(types); end
end

class T::Types::Untyped < ::T::Types::Base
  def initialize; end

  def name; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

module T::Utils
  def self.arity(method); end
  def self.coerce(val); end
  def self.methods_excluding_object(mod); end
  def self.register_forwarder(from_method, to_method, remove_first_param: _); end
  def self.run_all_sig_blocks; end
  def self.signature_for_instance_method(mod, method_name); end
  def self.string_truncate_middle(str, start_len, end_len, ellipsis = _); end
  def self.unwrap_nilable(type); end
  def self.wrap_method_with_call_validation_if_needed(mod, method_sig, original_method); end
end

module T::Utils::Nilable
  def self.get_type_info(prop_type); end
  def self.get_underlying_type(prop_type); end
  def self.get_underlying_type_object(prop_type); end
  def self.is_union_with_nilclass(prop_type); end
end

class T::Utils::Nilable::TypeInfo < ::Struct
  def is_union_type; end
  def is_union_type=(_); end
  def non_nilable_type; end
  def non_nilable_type=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

module T::Private::Abstract
end

module T::Private::Abstract::Data
  def self.get(mod, key); end
  def self.key?(mod, key); end
  def self.set(mod, key, value); end
  def self.set_default(mod, key, default); end
end

module T::Private::Abstract::Declare
  def self.declare_abstract(mod, type:); end
end

T::Private::Abstract::Declare::Abstract = T::Private::Abstract

T::Private::Abstract::Declare::AbstractUtils = T::AbstractUtils

module T::Private::Abstract::Hooks

  private

  def append_features(other); end
  def extend_object(other); end
  def inherited(other); end
  def prepended(other); end
end

module T::Private::Abstract::Validate
  def self.validate_abstract_module(mod); end
  def self.validate_subclass(mod); end
end

T::Private::Abstract::Validate::Abstract = T::Private::Abstract

T::Private::Abstract::Validate::AbstractUtils = T::AbstractUtils

T::Private::Abstract::Validate::Methods = T::Private::Methods

T::Private::Abstract::Validate::SignatureValidation = T::Private::Methods::SignatureValidation

module T::Private::Casts
  def self.cast(value, type, cast_method:); end
end

module T::Private::ClassUtils
  def self.replace_method(mod, name, &blk); end
end

class T::Private::ClassUtils::ReplacedMethod
  def initialize(mod, old_method, new_method, overwritten, visibility); end

  def bind(obj); end
  def restore; end
  def to_s; end
end

class T::Private::DeclState
  def active_declaration; end
  def active_declaration=(_); end
  def reset!; end

  def self.current; end
  def self.current=(other); end
end

module T::Private::ErrorHandler
  def self.handle_call_validation_error(signature, opts = _); end
  def self.handle_inline_type_error(type_error); end
  def self.handle_sig_builder_error(error, location); end
  def self.handle_sig_validation_error(error, opts = _); end
end

module T::Private::Methods
  def self._on_method_added(hook_mod, method_name, is_singleton_method: _); end
  def self.build_sig(hook_mod, method_name, original_method, current_declaration, loc); end
  def self.declare_sig(mod, &blk); end
  def self.finalize_proc(decl); end
  def self.has_sig_block_for_method(method); end
  def self.install_hooks(mod); end
  def self.maybe_run_sig_block_for_method(method); end
  def self.register_forwarder(from_method, to_method, mode: _, remove_first_param: _); end
  def self.run_all_sig_blocks; end
  def self.run_builder(declaration_block); end
  def self.run_sig(hook_mod, method_name, original_method, declaration_block); end
  def self.run_sig_block_for_method(method); end
  def self.sig_error(loc, message); end
  def self.signature_for_method(method); end
  def self.start_proc; end
  def self.unwrap_method(hook_mod, signature, original_method); end
end

T::Private::Methods::ARG_NOT_PROVIDED = T.let(T.unsafe(nil), Object)

module T::Private::Methods::CallValidation
  def self.create_validator_method(mod, original_method, method_sig, original_visibility); end
  def self.create_validator_method_fast(mod, original_method, method_sig); end
  def self.create_validator_method_fast0(mod, original_method, method_sig, return_type); end
  def self.create_validator_method_fast1(mod, original_method, method_sig, return_type, arg0_type); end
  def self.create_validator_method_fast2(mod, original_method, method_sig, return_type, arg0_type, arg1_type); end
  def self.create_validator_method_fast3(mod, original_method, method_sig, return_type, arg0_type, arg1_type, arg2_type); end
  def self.create_validator_method_fast4(mod, original_method, method_sig, return_type, arg0_type, arg1_type, arg2_type, arg3_type); end
  def self.create_validator_procedure_fast(mod, original_method, method_sig); end
  def self.create_validator_procedure_fast0(mod, original_method, method_sig); end
  def self.create_validator_procedure_fast1(mod, original_method, method_sig, arg0_type); end
  def self.create_validator_procedure_fast2(mod, original_method, method_sig, arg0_type, arg1_type); end
  def self.create_validator_procedure_fast3(mod, original_method, method_sig, arg0_type, arg1_type, arg2_type); end
  def self.create_validator_procedure_fast4(mod, original_method, method_sig, arg0_type, arg1_type, arg2_type, arg3_type); end
  def self.create_validator_slow(mod, original_method, method_sig); end
  def self.disable_fast_path; end
  def self.is_allowed_to_have_fast_path; end
  def self.report_error(method_sig, error_message, kind, name, type, value, caller_offset: _); end
  def self.validate_call(instance, original_method, method_sig, args, blk); end
  def self.wrap_method_if_needed(mod, method_sig, original_method); end
end

T::Private::Methods::CallValidation::CallValidation = T::Private::Methods::CallValidation

T::Private::Methods::CallValidation::Modes = T::Private::Methods::Modes

class T::Private::Methods::DeclBuilder
  def initialize(mod); end

  def abstract; end
  def bind(type); end
  def checked(level); end
  def decl; end
  def finalize!; end
  def generated; end
  def implementation; end
  def on_failure(*args); end
  def overridable; end
  def override(allow_incompatible: _); end
  def params(params); end
  def returns(type); end
  def type_parameters(*names); end
  def void; end

  private

  def check_live!; end
end

class T::Private::Methods::DeclBuilder::BuilderError < ::StandardError
end

class T::Private::Methods::Declaration < ::Struct
  def bind; end
  def bind=(_); end
  def checked; end
  def checked=(_); end
  def finalized; end
  def finalized=(_); end
  def generated; end
  def generated=(_); end
  def mod; end
  def mod=(_); end
  def mode; end
  def mode=(_); end
  def on_failure; end
  def on_failure=(_); end
  def override_allow_incompatible; end
  def override_allow_incompatible=(_); end
  def params; end
  def params=(_); end
  def returns; end
  def returns=(_); end
  def type_parameters; end
  def type_parameters=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class T::Private::Methods::DeclarationBlock < ::Struct
  def blk; end
  def blk=(_); end
  def loc; end
  def loc=(_); end
  def mod; end
  def mod=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

module T::Private::Methods::Modes
  def self.abstract; end
  def self.implementation; end
  def self.overridable; end
  def self.overridable_implementation; end
  def self.override; end
  def self.standard; end
  def self.untyped; end
end

T::Private::Methods::Modes::IMPLEMENT_MODES = T.let(T.unsafe(nil), Array)

T::Private::Methods::Modes::MODES = T.let(T.unsafe(nil), Array)

T::Private::Methods::Modes::NON_OVERRIDE_MODES = T.let(T.unsafe(nil), Array)

T::Private::Methods::Modes::OVERRIDABLE_MODES = T.let(T.unsafe(nil), Array)

T::Private::Methods::Modes::OVERRIDE_MODES = T.let(T.unsafe(nil), Array)

T::Private::Methods::PROC_TYPE = T.let(T.unsafe(nil), Object)

class T::Private::Methods::Signature
  def initialize(method:, method_name:, raw_arg_types:, raw_return_type:, bind:, mode:, check_level:, on_failure:, parameters: _, generated: _, override_allow_incompatible: _); end

  def arg_count; end
  def arg_types; end
  def bind; end
  def block_name; end
  def block_type; end
  def check_level; end
  def dsl_method; end
  def each_args_value_type(args); end
  def ever_failed; end
  def generated; end
  def has_keyrest; end
  def has_rest; end
  def keyrest_name; end
  def keyrest_type; end
  def kwarg_names; end
  def kwarg_types; end
  def mark_failed; end
  def method; end
  def method_desc; end
  def method_name; end
  def mode; end
  def on_failure; end
  def override_allow_incompatible; end
  def owner; end
  def parameters; end
  def req_arg_count; end
  def req_kwarg_names; end
  def rest_name; end
  def rest_type; end
  def return_type; end

  def self.new_untyped(method:, mode: _, parameters: _); end
end

T::Private::Methods::Signature::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

module T::Private::Methods::SignatureValidation
  def self.validate(signature); end
  def self.validate_non_override_mode(signature); end
  def self.validate_override_mode(signature, super_signature); end
  def self.validate_override_shape(signature, super_signature); end
  def self.validate_override_types(signature, super_signature); end
end

T::Private::Methods::SignatureValidation::Methods = T::Private::Methods

T::Private::Methods::SignatureValidation::Modes = T::Private::Methods::Modes

module T::Private::MixesInClassMethods
  def included(other); end
end

module T::Private::Mixins
  def self.declare_mixes_in_class_methods(mixin, class_methods); end
end

module T::Private::RuntimeLevels
  def self._toggle_checking_tests(checked); end
  def self.check_tests?; end
  def self.default_checked_level; end
  def self.default_checked_level=(default_checked_level); end
  def self.enable_checking_in_tests; end
end

T::Private::RuntimeLevels::LEVELS = T.let(T.unsafe(nil), Array)

module T::Private::Types
end

class T::Private::Types::NotTyped < ::T::Types::Base
  def name; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

T::Private::Types::NotTyped::ERROR_MESSAGE = T.let(T.unsafe(nil), String)

class T::Private::Types::StringHolder < ::T::Types::Base
  def initialize(string); end

  def name; end
  def string; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

class T::Private::Types::Void < ::T::Types::Base
  def name; end
  def valid?(obj); end

  private

  def subtype_of_single?(other); end
end

T::Private::Types::Void::ERROR_MESSAGE = T.let(T.unsafe(nil), String)

module T::Private::Types::Void::VOID
end
